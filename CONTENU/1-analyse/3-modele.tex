\newpage
\section{Langages de représentation}\label{sec:mods}

% \subsection{Langages de balisages }
\subsection{XML (t)}
The eXtended Markup Language (XML) aims to give a hierarchical structure to  text in a machine-, yet human-readable way. It is widely used to store or exchange information as it also supports Unicode.
XML is formally defined as a Standard Generalized Markup Language's subset (SGML) designed to improve parser efficiency. Work on XML began in 1996 and it became a W3C Recommendation in early 1998.

\paragraph{Mark-up}
This is achieved by adding mark-up elements that are easily noticed as they begin with '<' and end with a '>'. Mark-up elements are used to enclose unicode text, and give thus a mean to identify them and possibly to process it. As its name indicates, it is said extensible because we can define our own mark-up elements and writes a line like that:

\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
opening mark-up element 			enclosing mark-up element
<structural_element>Some unicode text inside</structural_element>
\end{Verbatim}

Attributes can be defined for each mark-up element. 
For instance, the xml:lang attributes indicates the natural language used to write the enclosed text. The \gui{1812 Overture} full title can be written like that:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<title xml:lang='ru'>Торжественная увертюра 1812 года, Toržestvennaja uvertjura 1812 goda</title>
<title xml:lang='fr'>Ouverture Solennelle, L'Année 1812, Op. 49</title>
\end{Verbatim}

\paragraph{Syntax}
XML does not only enclose text with mark-up elements. It also enables to imbricate mark-up elements in such a way that the elements conforms to a tree structure. 

\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<element>
	<sub-element>Example of text</sub-element>
</element>
\end{Verbatim}

Other syntaxic rules have been defined to enables conforming parser to process XML file. Any file conspuing to these rules is said to be well-formed.

\paragraph{Schema}
Furthermore, if XML provides us with a syntax we also have the ability to makes purpose-specific XML-based mark-up languages – i.e. define constraints on structure, mark-up elements or even datatyping definition. Indeed, several schema languages exists and are used to encode documents or serialize text data according to a particular schema. XML files complying with a schema – i.e. conforming to the constraints defined in the schema – are said to be valid.

\paragraph{Namespace}
When creating schemas, ambiguity problems usually arise and namespace declaration can take care of that. Indeed, it provides an abstract container for XML elements and attributes and gives to their name a scope. As each namespace is identified by an URI, the ambiguity between identically named elements or attributes from differents namespace can be resolved. 

Therefore, I can declare my own \gui{title} element and simultaniously use the \gui{DC Terms} property title. We show here a complete example with xml heading:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<?xml version="1.0" encoding="UTF-8"?>
<ex:musical_opus xmlns:dc="http://purl.org/dc/elements/1.1/"
    			 xmlns:ex="http://example.org">
	<dc:title>1812 Overture</dc:title>
    <ex:title>Festival Overture, The Year 1812</ex:title>
</ex:musical_opus>
\end{Verbatim}

In this example, dc:title and ex:title denotes two different elements for which we can give informally different meaning – ex:title indicating the complete name, dc:title a short version. 

\subsubsection*{XML Schema}
This W3C recommendation was published in 2001 and is one of several xml schema languages\footnote{We can cite, the old and very simple \gui{Document Type Defintion}(DTD) as well as the major rival of XML Schema, namely \gui{Relax NG}.}. It is often called XSD in reference to its files suffix – '.xsd'.

XSD can define imbrication, quantification and naming rules for xml elements and attributes – in order to enable vocabulary and content model validation. XSD also supports namespace so parts of other schemas can be included or imported. 

\paragraph{Datatypes}
But one of the main and most criticized characteristic of XSD is DataType validation. It can be applied to elements or attributes to constraint their content.  DataType definition must use XSD primitive or derived datatypes – see the scheme for a detailled hierarchy. This dependence upon specific datatypes is the source of many criticism. 

Derived datatypes can be built by restriction – of the permitted values set –, list – declaration of values –, or union – between several types. 
As an complete example, we define a XSD schema describing \gui{MusicalOpus} as a list of XML elements named:
\begin{liste}
	\item Title: title of the musical opus
	\item Extent: length or duration – as a string
	\item Composer: name of the composer
	\item composed: date of composition of the opus – only the year
	\item Performer: name of the performer
	\item performed: date of performance – only the year
	\item conductedby: name of the person who conducted the performer, this attribute is declared optionnal – thanks to the minOccurs attribute
	\item ComposerNationality: picked from a list of value we enumerate in the scheme
\end{liste}

Here is the resulting XSD scheme:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<?xml version="1.0" encoding="utf-8"?> 
<xs:schema elementFormDefault="qualified"   xmlns:xs="http://www.w3.org/2001/XMLSchema"> 
 <xs:element name="MusicalOpus"> 
   <xs:complexType> 
     <xs:sequence> 
       <xs:element name="Title" type="xs:string" /> 
       <xs:element name="Extent" type="xs:string" /> 
       <xs:element name="Composer" type="xs:string" /> 
       <xs:element name="composed" type="xs:gYear" /> 
       <xs:element name="Performer" type="xs:string" /> 
       <xs:element name="performed" type="xs:gYear"/> 
       <xs:element name="conductedBy" type="xs:string" minOccurs="0"/>  
       <xs:element name="ComposerNationality"> 
         <xs:simpleType> 
           <xs:restriction base="xs:string"> 
             <xs:enumeration value="FR" /> 
             <xs:enumeration value="DE" /> 
             <xs:enumeration value="RU" /> 
             <xs:enumeration value="UK" /> 
             <xs:enumeration value="US" /> 
           </xs:restriction> 
         </xs:simpleType> 
       </xs:element> 
     </xs:sequence> 
   </xs:complexType> 
 </xs:element> 
</xs:schema> 
\end{Verbatim}


And we provide a XML file which states that it conforms to the previous XSD scheme through a xsi:noNamespaceSchemaLocation attribute:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<?xml version="1.0" encoding="utf-8"?> 
<MusicalOpus xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:noNamespaceSchemaLocation="MusicalOpus.xsd"> 
  <Title>Festival Overture, The Year 1812</Title> 
  <Extent>14:19</Extent> 
  <Composer>Pyotr Ilyich Tchaikovsky</Composer> 
  <composed>1880</composed> 
  <Performer>Minneapolis Symphony Orchestra</Performer> 
  <performed>1954</performed> 
  <conductedBy>Antal Dorati</conductedBy> 
  <conductedBy>Harold Lawrence</conductedBy> 
  <ComposerNationality>RU</ComposerNationality> 
</MusicalOpus> 
\end{Verbatim}






















\subsection{Ontologie et modèle conceptuel}\label{sec:onto-mc}
\subsubsection{Resource Description Framework (t)}
% \addcontentsline{toc}{subsubsection}{Resource Description Framework}
The Resource  Description Framework (RDF) is an abstract model which is part of the W3C recommendations for the Semantic Web. 
Let's just bring back to mind how \pc{Tim Berners-Lee} defined it to set RDF back into its context of creation: 

\ciel{
The Semantic Web is not a separate Web but an extension of the current one, in which information is given well-defined meaning, better enabling computers and people to work in cooperation.}

Indeed, RDF aims to describe and link resources – and no more web pages – in a simple, all-purpose and machine-readable way. 
The focus on software agents led to choose a formal semantic and provable inference. 
Thus, such descriptions will foremost benefits to software agents which we'll be able to exploit, process and search into this web of linked data. 

\paragraph{Statements / Triples}
The description consists in making statements that describes or models web resources. The statements are formed as subject-predicate-object sentence called triples that can be represented as a graph – one node/vertex for the subject and the object, and a directed and labeled edge for the predicate. 
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
Subject		Predicate	    Object	
Tchaikovsky ---- is the Composer of ----> 1812 overture
\end{Verbatim}
Thereby, a set of statements constitute a multigraph, that is a graph in which node/vertex can have multiple ingoing or outgoing edges resulting possibly in loops. 
However, unlike an hypertext the rdf multigraph has labelled edges – also called properties -- connecting a resource with another resource or a literal value.

\paragraph{URI, datatype and literals}
RDF is said to have an URI-based vocabulary, meaning that resources and properties and typed literal are identified by URI reference. 
Indeed, unlike plain literals, typed literals are literals combined with a datatype URI.
Datatypes in RDF are compatible with XML Schema datatypes --which can thus be used as there are-- but any datatype definition conforming to RDF constraints may be used.

Let's rewrite our previous example with Tchaikovsky:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
Subject:  http://example.org/Tchaikovsky
Property: http://example.org/Composer
Object:   http://example.org/1812_Overture
\end{Verbatim}

And now an example with a gYear XSD datatype:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
Subject:  http://example.org/1812_Overture
Property: http://example.org/composed
Object:   '1880' xsd:gYear
\end{Verbatim}
The following examples make use of the namespace ability to ease the reading. We define here the prefix used for our example and for specific rdf elements:
\begin{liste}
	\item \cd{Example prefix: 'ex:'	Example URI: 'http://example.org'}
	\item \cd{RDF prefix: 'rdf:'	RDF URI:'http://www.w3.org/1999/02/22-rdf-syntax-ns\#'}
\end{liste}
Our previous example could then be written like that:
\cd{ex:1812\_Overture  -- ex:composed -->  '1880' xsd:gYe}


\paragraph{Structured value}
When we want to define a resource composed in fact of several other resources or literals, 
RDF makes us declare an intermediate node – only to conform to the RDF syntax. 
This kind of nodes are called blank nodes because they don't really need to be referenced by an URI. 
As they are only a product of the RDF syntax and don't represent anything in particular they can stay anonymous.

Indeed, when we declare the size of a digital file such as an audio file, we may want to specify the unit. 
Thus considering that the following statement is not sufficient:
\cd{ex:audio\_file\_01  ex:size '33,7'}

So we need to define one blank node and use a particular RDF property called value:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
ex:audio_file_01 	-- ex:size -->	_blank_node_01
_blank_node_01	-- rdf:value -->	'33,7'
_blank_node_01	-- ex:unit -->	ex:Mb xsd:decimal
\end{Verbatim}

The value property is not the only one to be used in such context. 
The type property states the nature of a blank node. 
An example will be shown in the next paragraph.

\paragraph{Grouping resources}
% 7.2.3.a  containers
RDF provides two different ways to group things. The first one is called Containers comprises three predefined types which points out some members of the group they define:
\begin{liste}
	\item a bag define a non-ordered group that may include duplicate members. 
	\item a seq define an ordered group that may include duplicate members.
	\item a alt define a group of alternatives resources or literals. 
\end{liste}

Members may be resources or literal, their membership is stated by declaring them as list item (li).
We show here example connected to our information sample. First, a bag of \gui{Performer} having played the \gui{1812 overture}, then a seq describing the content of the audio CD. 
Eventually, an alt group of russian, french and english version of \gui{Tchaikovsky}'s full name.

1) Bag of \gui{Performer}
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
ex:1812_Overture	-- ex:Performer -->	_blank_node_02
_blank_node_02	-- rdf:type -->		rdf:bag
_blank_node_02	-- rdf:li -->		ex:Minneapolis_S_O
_blank_node_02	-- rdf:li -->		ex:St_Petersburg_Ph
\end{Verbatim}
2) Seq of audio tracks from \gui{Tchaikovsky: 1812 Festival Overture; Capriccio Italien; Beethoven:  Wellington's Victory} CD:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
ex:1812_Op49_CD	-- ex:TrackList -->	_blank_node_03
_blank_node_03	-- rdf:type -->		rdf:seq
_blank_node_03	-- rdf:li -->		ex:Op49_audio
_blank_node_03	-- rdf:li -->		ex:Op49_commentary
_blank_node_03	-- rdf:li -->		ex:Capriccio_Italien_audio
_blank_node_03	-- rdf:li -->		ex:Wellington_Op91_audio01
_blank_node_03	-- rdf:li -->		ex:Wellington_Op91_audio02
_blank_node_03	-- rdf:li -->		ex:Op91_commentary
\end{Verbatim}
3) Alt names of \gui{Tchaikovsky}
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
ex:Tchaikovsky		-- ex:Name -->		_blank_node_04
_blank_node_04	-- rdf:type -->		rdf:alt
_blank_node_04	-- rdf:li -->		'Pyotr Ilyich Tchaikovsky' @en
_blank_node_04	-- rdf:li -->		'Piotr Ilitch Tchaïkovski' @fr
_blank_node_04	-- rdf:li -->		'Пётр Ильич Чайкoвский' @ru
\end{Verbatim}

% 7.2.3.b  collection
Unlike containers, collections can make a closed group definition, that is list all members member of the collection. With a container you can not state that there  is no other member than those you give in your definition. 
Moreover, list have predefined properties to identify the first item, the rest of the list and the end of it – a nil property. 

A rewriting of our tracklist example as a list would be:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
ex:1812_Op49_CD	-- ex:TrackList -->	_blank_node_03
_blank_node_03	-- rdf:type -->		rdf:list
_blank_node_03	-- rdf:first -->		ex:Op49_audio
_blank_node_03	-- rdf:rest -->		ex:Op49_commentary
_blank_node_03	-- rdf:rest -->		ex:Capriccio_Italien_audio
_blank_node_03	-- rdf:rest -->		ex:Wellington_Op91_audio01
_blank_node_03	-- rdf:rest -->		ex:Wellington_Op91_audio02
_blank_node_03	-- rdf:rest -->		ex:Op91_commentary
_blank_node_03	-- rdf:rest -->		rdf:nil
\end{Verbatim}

\paragraph{Serialization format}
As an abstract model, RDF statements can be serialized or represented in a variety of form. The most widely known is the \gui{RDF XML} but the W3C also introduced the more readable \gui{Notation} (N3) based on tabular spacing. This last form is closely related to the \gui{Turtle} and \gui{N-Triples} formats.





\subsubsection{RDF Schema (t)}
% \addcontentsline{toc}{subsubsection}{RDF Schema}
RDFS is the result of 6 years of work from the W3C consortium – from the 1998's first version to the 2004's final recommendation. 
It is formally introduced as a vocabulary description language intended to structure RDF resources. 
Indeed, RDFS presents mechanisms for describing classes of resources, associated properties and also the relationships between properties and other resources. 

These mechanisms are in fact itselves classes and properties that enables us to describe vocabulary or basic ontology. 
Like RDF, RDFS follows a minimalistic approach allowing a relatively basic expressiveness compared to the Ontology Web Language (OWL) – which is built upon it.

\paragraph{RDF(S) Class}
Classes are resources – identified by an URI, described by properties – associated with a set of resources called the class extension. 
Resources in the class extension  are called instances – the rdf:type property may be used to state a resource as an instance of a class. 
Note that a class extension can cointain the class itself as instance – this is why rdfs:Class can be defined as a rdfs:Class in the table below.
SubClasses may be defined by the SubClassOf property. In this case, their extension pertains necessarily to any upper class extension. 
If we state \gui{X} to be the class of all \gui{Opus} and \gui{Y} a sub-class of \gui{X} containing all the \gui{MusicalOpus} ; then every instance of \gui{Y} will be an instance of \gui{X}. 

% \paragraph{Class List}
\begin{table}[ht!]
   \begin{center}
		\begin{tabularx}{400pt}{|l|X|}
		   \hline
		Class name & Comment\\ \hline\hline
		rdfs:Resource & The class resource, everything.\\ \hline
		rdfs:Literal & The class of literal values, e.g. textual strings and integers.\\ \hline
		rdf:XMLLiteral & The class of XML literals values.\\ \hline
		rdfs:Class & The class of classes.\\ \hline
		rdf:Property & The class of RDF properties.\\ \hline
		rdfs:Datatype & The class of RDF datatypes.\\ \hline
		rdf:Statement & The class of RDF statements.\\ \hline
		rdf:Bag & The class of unordered containers.\\ \hline
		rdf:Seq & The class of ordered containers.\\ \hline
		rdf:Alt & The class of containers of alternatives.\\ \hline
		rdfs:Container & The class of RDF containers.\\ \hline
		rdfs:ContainerMembershipProperty & The class of container membership properties, rdf:\_1, rdf:\_2, \dots, all of which are sub-properties of 'member'.\\ \hline
		rdf:List & The class of RDF Lists.\\ \hline
		\end{tabularx}
		\caption{Class list \label{tab:rdfs-classes}}
   \end{center}
\end{table}

\paragraph{RDF(S) Properties}
First of all, let's recall that all properties are instances of the rdf:Property class. A property link a pair of resources, one of them as a subject and the other one as the object. 
RDFS introduces two properties to restrict which can of resources may be linked together. rdfs:domain constraints the subject resource to be an instance of a given class whereas rdfs:range constraints the objet resource likewise. 
SubProperty relationships – stated with rdfs:subPropertyOf – induces that all pairs of resource linked are also linked by the upper property. 
Thus, having a \gui{Contributor} property and a \gui{Performer} sub-property we can state that:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
ex:1812\_Overture
ex:Performer
ex:Minneapolis\_SO
\end{Verbatim}
and this would entail:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
ex:1812\_Overture
ex:Contributor
ex:Minneapolis\_SO
\end{Verbatim}

% 7.3.2.a  Property List
\begin{table}[ht!]
   \begin{center}
		\begin{tabularx}{450pt}{|l|X|c|c|}
		   \hline
rdf:type & The subject is an instance of a class. & rdfs:Resource & rdfs:Class \\ \hline
rdfs:subClassOf & The subject is a subclass of a class. & rdfs:Class & rdfs:Class \\ \hline
rdfs:subPropertyOf & The subject is a subproperty of a property. & rdf:Property &rdf:Property \\ \hline
rdfs:domain & A domain of the subject property. & rdf:Property & rdfs:Class\\ \hline
rdfs:range & A range of the subject property. & rdf:Property & rdfs:Class\\ \hline
rdfs:label & A human-readable name for the subject. & rdfs:Resource & rdfs:Literal \\ \hline
rdfs:comment & A description of the subject resource. & rdfs:Resource & rdfs:Literal\\ \hline
rdfs:member & A member of the subject resource. & rdfs:Resource & rdfs:Resource\\ \hline
rdf:first & The first item in the subject RDF list. & rdf:List & rdfs:Resource\\ \hline
rdf:rest & The rest of the subject RDF list after the first item. & rdf:List & rdf:List\\ \hline
rdfs:seeAlso & Further information about the subject resource. & rdfs:Resource &rdfs:Resource\\ \hline
rdfs:isDefinedBy & The definition of the subject resource. & rdfs:Resource & rdfs:Resource\\ \hline
rdf:value & Idiomatic property used for structured values (see the RDF Primer for an example of its usage). & rdfs:Resource & rdfs:Resource\\ \hline
rdf:subject & The subject of the subject RDF statement. & rdf:Statement & rdfs:Resource\\ \hline
rdf:predicate & The predicate of the subject RDF statement. & rdf:Statement & rdfs:Resource\\ \hline
rdf:object & The object of the subject RDF statement. & rdf:Statement & rdfs:Resource\\ \hline
		\end{tabularx}
		\caption{Class list \label{tab:rdfs-classes}}
   \end{center}
\end{table}

Eventually, observe these four properties that appear more like annotation than property defining resource: \cd{rdfs:label, rdfs:comment, rdfs:seeAlso, rdfs:isDefinedBy}.





\subsubsection{Ontology Web Language (t)}
% \addcontentsline{toc}{subsubsection}{Ontology Web Language}
The Ontology Web Language (OWL) is a knowledge representation language intended – as its name states – to build ontology in a web environnement. 
OWL relies on RDF and XML syntax and defines its constructs as extension or subset of RDF/RDFS classes and properties. 
Nevertheless, OWL provides in addition comparaison and cardinality constraints on classes or properties. 
These constructs enables to model domain specific ontology while bringing along generic reasoning tool. 

The W3C created a working group in 2001 and documents became recommendations in 2004.
However, OWL was a revision of earlier work called DAML+OIL initiated conjointly by the \gui{Defense Advanced Research Projects Agency} (DARPA) and the European Union's \gui{Information Society Technologies} (IST) project. 

\paragraph{OWL species}
OWL defines in fact three sub-languages with different level of expressiveness and thus computational efficiency:
\begin{liste}
	\item \gui{OWL Lite} is the simplest, less expressive sub-language. 
	It supports 0..1 cardinality constraints and thus are intended for thesauri and taxonomies migration project.

	\item \gui{OWL DL} gives full expressivity while ensuring computational completeness – all entailments are garanteed to be computed – and decidability – all computations will finish in finite times. 
	Full expressivity means it includes all language constructs but to ensure the rest it needs to restrict their use by some conditions. 

	\item \gui{OWL Full} gives full expressivity without conditions. For instance, a major difference with \gui{OWL DL} is that all resources can be considered as individuals – even Class and Property. 
	There are strong equivalence between \gui{OWL Full} and RDF – RDFS. This comes nevertheless with no computational garantees. 
\end{liste}
Each level is a sub-level from its predecessor, that is every legal ontology or valid conclusion expressed in \gui{OWL Lite} is a legal ontology or respectively a valid conclusion in \gui{OWL DL} and so on between \gui{OWL DL} and \gui{OWL Full}. 

\paragraph{Class}
OWL defines its class like RDFS except that only OWL Full can state that a class is an instance of another class. 
OWL Lite and DL don't allow a class to be considered at the same time as an individual – thus also as a member of a class extension. 
% 7.4.2.a  Class descriptions
OWL supports six different kind of class descriptions: 
\begin{liste}
	\item a simple class declaration – with a URI reference (\cd{<owl:Class rdf:ID='Composer' />}).

	\item an exhaustive enumeration of the class extension. Or if we want to define directly its extension like RDFS Containers, we can write:
	\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<owl:Class rdf:ID='Nationality'>
	<owl:oneOf rdf:parseType='Collection'>
		<owl:Thing rdf:about='ex:French' />
		<owl:Thing rdf:about='ex:Russian' />
		<owl:Thing rdf:about='ex:English' />
	</owl:oneOf>
</owl:Class>
	\end{Verbatim}

	\item definition of a class as a subset of another class depending on property restrictions. 
	We may also use more complex property restrictions, including value or  cardinality restrictions. 
	For this purpose we have a set of properties:
	\begin{liste}
		\item \cd{owl:allValuesFrom}, \cd{owl:someValuesFrom} --- with the values being either a class or a datatype but OWL Lite only supports class value.
		\item \cd{owl:hasValue} --- the value has to be either an individual or a data value. This property is not included in OWL Lite. 
		\item \cd{owl:maxCardinality}, \cd{owl:minCardinality}, \cd{owl:cardinality} --- the value has to be related to a XML Schema datatype.
	\end{liste}

	\item \cd{owl:intersectionOf} --- an intersection of several classes descriptions in a similar fashion to an AND operator acting on  class declaration. 
	This property can be used in some way in OWL Lite.
	\item \cd{owl:unionOf} --- an union of several classes descriptions in a similar fashion to an OR operator acting on class declaration. 
	This property is not included in OWL Lite. 
	\item \cd{owl:complementOf} --- a complement of a class description similar to a NOT operator acting on class declaration. 
	This property is not included in OWL Lite.
\end{liste}


\paragraph{Class axioms}
Classes may be described with the previous properties, class axioms are the three properties that have owl:Class for domain and range: 
\begin{liste}
	\item \cd{owl:subClassOf} enables specialisation to be described. The sub-class' extension set is thus stated as a subset of the class extension set. 

	\item \cd{owl:equivalentClass} declares class extension equivalence between two classes descriptions.

	\item \cd{owl:disjointWith} establishes that two classes extensions of two classes descriptions have no member in common.
\end{liste}
Note that all owl:Class are sub-classes of the owl:Thing superclass. 

\paragraph{Property}
OWL defines four kind of Property that must be mutually disjoint when using OWL DL:
\begin{liste}
	\item \cd{owl:DatatypeProperty} links instance with literal values.
	\item \cd{owl:ObjectProperty} define relations between instances.
	\item \cd{owl:AnnotationProperty} are intended for human reader. 
	In OWL DL, it is impossible to define restriction or sub-property for Annotation Properties and information will not be taken into account by reasoners.
	\item \cd{owl:OntologyProperty} are used for importing ontology and make statements about versionning information. 
	In OWL DL, the same constraints hold as those specified for Annotation Properties.
\end{liste}

\paragraph{Property declaration}
We take as an example the definition of creation relationships on two different level of specialisation. 
First, a \gui{createdBy} relation between a \gui{Person} and an \gui{Opus}. 
Second, a music related \gui{composedBy} relation, involving a \gui{Composer} and a \gui{MusicalOpus}.

Class declaration:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<owl:Class rdf:ID='Composer'>
	<rdfs:subClassOf rdf:resource='Person' />
</owl:Class>
<owl:Class rdf:ID='Opus' />
<owl:Class rdf:ID='MusicalOpus'>
	<rdfs:subClassOf rdf:resource='Opus' />
</ow:Class>
\end{Verbatim}

Property declaration:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<owl:ObjectProperty rdf:ID='createdBy'>
	<rdfs:domain rdf:resource='Opus' />
	<rdfs:range rdf:resource='Person' />
</owl:ObjectProperty>
<owl:ObjectProperty rdf:ID='composedBy'>
	<rdfs:domain rdf:resource='MusicalOpus' />
	<rdfs:range rdf:resource='Composer' />
	<rdfs:subPropertyOf rdf:resource='createdBy />
</owl:ObjectProperty>
\end{Verbatim}
Note the use of rdfs:domain, rdfs:range, rdfs:subPropertyOf and rdfs:subClassOf properties within OWL statements.

Now, if we want to take advantage of Property restrictions to define our \gui{Composer} class, we can state for instance that \gui{Composer} individuals are precisely those \gui{Person} individuals who have \gui{composed} at least one \gui{MusicalOpus}. 
This lead us to write the following declaration: 
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<owl:Class rdf:ID='Composer'>
  <rdfs:subClassOf>
    <owl:intersectionOf rdf:parseType='Collection'>
      <owl:Class rdf:ID='Person' />
      <owl:Restriction>
        <owl:onProperty rdf:resource='composedBy' />
        <owl:minCardinality rdf:datatype='\&xsd;nonNegativeInteger'>1</owl:minCardinality>
      </owl:Restriction>
    </owl:intersectionOf >
  </rdfs:subClassOf>	
</owl:Class>
\end{Verbatim}
Note that the intersectionOf property requires a list of Classes declarations which can be given either by owl:Class or owl:Restriction – which is defined as a sub-class of owl:Class. 

\paragraph{Property characteristics}
Properties can also be defined as:
\begin{liste}
	\item \e{transitive}: P(x,y) and P(y,z) implies P(x,z). For instance, if x is located in y and y is located in z, then x is located in z. 
	\item \e{symetric}: P(x,y) if and only if P(y,x). If x is next to y, then y must be next to x. 
	\item \e{functionnal}: P(x,y) and P(x,z) implies y = z. The property has only one value for each individual it applies to. 
	\item \e{inverseOf}: P1(x,y) if and only if P2(y,x). If x is the \gui{fatherOf} y, then y is the \gui{childOf} x, thus making \gui{fatherOf} the inverseOf \gui{childOf} property. 
	\item \e{inverseFunctional}: P(y,x) and P(z,x) implies y = z.
\end{liste}


\paragraph{Individual}
Ontology is not only about Classes and Properties, it enables us to state some facts about individuals. In order to describe them, we state them as Class instance, make use of Property or assert facts about their individuality. 
Let's use our previous ontology description to decribe \gui{Tchaikovsky} and the \gui{1812 overture}.
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<Person rdf:ID='Tchaikovsky' />
<MusicalOpus rdf:ID='1812_Overture'>
	<composedBy rd:resource='Tchaikovsky' />
</MusicalOpus>
\end{Verbatim}

From this description, we can entail that:
\gui{Tchaikovsky} is not only a \gui{Person}, it is also a \gui{Composer} because he composed the \gui{1812 overture}. As he composed it, we can also say that he has \gui{created} it. 

As OWL is a web language, it has rejected the \gui{unique name} assumption and hence need to deal with identity uniqueness – and thus URI reference. In order to do so, three constructs have been defined:
owl:sameAs states that two URI reference refer in fact to the same individual, meaning we can merge their definition and the related conclusions. 
owl:differentFrom declares that two URI reference refer to different individuals. 
owl:AllDifferent provides an idiom for stating that a list of individuals are all different. 

Now, to demonstrate the use of sameAs property and to refer to our information sample, we define several \gui{Tchaikovsky} individuals with different spelling. Then, we declare several MusicalOpus, \gui{Cappricio italien} and «\verb?Ромео и Джульетта?» which is the russian spelling for \gui{Romeo and Juliet}.

\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<Person rdf:ID='Tchaïkovski' xml:lang='fr' />
<Person rdf:ID='Чайкoвский' xml:lang='ru' />

<MusicalOpus rdf:ID='Capriccio_italien' xml:lang='fr'>
	<composedBy rd:resource='Tchaïkovski' />
</MusicalOpus>
<MusicalOpus rdf:ID='Ромео и Джульетта' xml:lang='ru'>
	<composedBy rd:resource='Чайкoвский' />
</MusicalOpus>
\end{Verbatim}
If we change the first statements by:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<Person rdf:ID='Tchaïkovski' xml:lang='fr'>
	<owl:sameAs rdf:resource='Tchaikovsky'/>
</Person>
<Person rdf:ID='Чайкoвский' xml:lang='ru'>
	<owl:sameAs rdf:resource='Tchaikovsky'/>
</Person>
\end{Verbatim}
We can entail that there are the same person and that he has composed all three \gui{MusicalOpus} described. 
















\subsection{Thésaurus et vocabulaire structuré}\label{sec:thesaurus}
\subsubsection{Simple Knowledge Organization System (m)}\label{sec:skos}
% \addcontentsline{toc}{subsubsection}{Simple Knowledge Organization System}
\e{
SKOS est un langage de représentation de vocabulaires structurés et de thésaurus qui repose sur RDF et OWL. 
Son objectif est de représenter tout type de SOC en vue de le publier sur le web de données,  liées et ouvertes (Linked Open Data). 
En témoigne les travaux et méthodes de conversion proposés par \cite{Summers2008} ou \cite{VanAssem2006} et les applications de gestion de thésaurus développés autour de SKOS, comme celle de \cite{Schandl2010}.
On notera que l'objectif de publication semble pousser vers une représentation minimale mais extensible de SOC déjà construits.
}

\paragraph{Concept et Etiquette}
SKOS centre son modèle sur les concepts (\cd{skos:Concept}) et considère les étiquettes comme des propriétés de ces derniers. 
On distingue trois types d'étiquettes: 
\begin{itemize} 
	\item les étiquettes préférées (\cd{skos:prefLabel}) qui sont uniques par langue et servent de référence.
	\item les étiquettes alternatives (\cd{skos:altLabel}) qui servent de synonymes pour l'étiquette de référence. 
	\item les étiquettes cachées (\cd{skos:hiddenLabel}) qui servent à la récupération d'erreurs de frappes les plus courantes. 
\end{itemize}
Chacune de ces propriétés est formalisée comme une instance de \cd{owl:Anno\-tationProperty}, ce qui permet de l'attacher dans les faits à tout type d'éléments ontologiques, et pas seulement à des concepts. 
Les valeurs lexicales portées par ces étiquettes sont formalisées comme des \cd{rdf:PlainLiteral}, ce qui permet de spécifier la langue et l'alphabet utilisés. 
Par exemple, la chaîne "higashi"@ja-Latn correspond à un mot japonais écrit avec l'alphabet latin.

\paragraph{Documentation}
Différentes notes de documentation existent afin de :
\begin{itemize}
	\item définir un concept (\cd{skos:definition}), expliciter son contexte d'usage (\cd{skos:scopeNote}) ou donner des exemples (\cd{skos:example})
	\item spécifier l'historique de sa signification (\cd{skos:historyNote}), les changements effectués (\cd{skos:changeNote}) ou à faire (\cd{skos:editorialNote})
\end{itemize}
L'ensemble de ces notes est défini comme une spécialisation de \cd{skos:note}, formalisé comme une \cd{owl:annotationProperty}. 
De cette manière, les notes peuvent servir à porter de la documentation écrite (comme les étiquettes), pointer vers des ressources RDF ou des documents identifiés par une URI. 
Cela permet ainsi de prévoir l'extension de ces notes à des besoins plus spécifiques.


\paragraph{Groupes et relations entre Concepts}
Les concepts peuvent être regroupés dans des schémas conceptuels (\cd{skos:\-ConceptScheme} et relation \cd{skos:inScheme}) et structurés par différentes relations:
\begin{itemize}
	\item des relations de structuration hiérarchiques (\cd{skos:broader}, \cd{skos:na\-rrower}) ou associatives (\cd{skos:related})
	\item des relations de correspondances entre concepts de schémas différents, soit une relation d'équivalence exacte (\cd{skos:exactMatch}), une équivalence approximative (\cd{skos:closeMatch}), des relations hiérarchiques (\cd{skos:broadMatch}, \cd{skos:narrowMatch}) ou associative \cd{skos:rela\-ted\-Match}).
\end{itemize}



\paragraph{Exemple de représentation} 
Pour illustrer l'utilisation de SKOS, nous reprendrons le scénario présenté dans notre cahier des charges fonctionnels (\ref{sec:cdcf}). 
Il s'agit de représenter deux termes de jargons correspondant au même concept de cadrage.
En effet, les deux organisations ont décidé de lier la définition de leur concept malgré leur usage d'étiquettes différent. 
Ceci se reflète par la mise en relation explicite de ces concepts (\cd{skos:exactMatch}) et leur incorporation dans des schèmes différents (\cd{skos:inScheme}).
Par ailleurs, la VRT utilise des étiquettes cachées pour gérer l'utilisation d'abréviations par les utilisateurs écrivant leurs requêtes. 
Afin de satisfaire aux besoins des amateurs, on rajoute également une illustration graphique ainsi qu'une définition :
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
//====== CONCEPTS ======//
<PlanAmericain> rdf:type skos:Concept ; 
  skos:prefLabel "Plan américain"@fr ;
  skos:prefLabel "American shot"@en
  skos:altLabel "Plan 3/4"@fr ;
  skos:altLabel "Medium-close shot"@en ;
  skos:inScheme   <RTBF-Scheme> ;
  skos:inScheme   <AV-Scheme> ;
  skos:example ex:PlanAmericain.png ;                               //Illustration//
  skos:definition "plan coupant les personnages à mi-cuisse"@fr ;   //Définition//
  skos:exactMatch <Plan34> .
   
<Plan34> rdf:type skos:Concept ;
  skos:prefLabel "3/4 shot"@en
  skos:prefLabel "Plan 3/4"@fr ;
  skos:altLabel "Medium-close shot"@en ;
  skos:hiddenLabel "mcs"@en ;                                           //Abréviations//
  skos:hiddenLabel "m.c.s."@en ;
  skos:example ex:PlanAmericain.png ;                                   //Illustration//
  skos:definition "shows a character from head to the middle of the leg"@en ;
  skos:inScheme   <AV-Scheme> ;
  skos:inScheme   <VRT-Scheme> .
\end{Verbatim}



\paragraph{SKOS-XL}\label{sec:skos-xl}
SKOS-XL est une extension de SKOS développée courant 2008 pour proposer une modélisation alternative au vocabulaire de base et favoriser des extensions plus fines. 
Dans SKOS-XL les termes ne sont plus portés par les concepts mais deviennent des éléments à part entière (\cd{skosxl:Label}). 

Les relations d'attachement entre termes et concepts sont analogues aux attributs de SKOS mais les formalisent comme des instances de \cd{owl:objectProperty}. 
Le domaine de ces relations n'est pas défini ce qui permet de les associer à n'importe quelle ressource RDF, et donc en particulier aux concepts SKOS mais également à des ConceptScheme. 
Si cette dernière possibilité permet de créer des groupes de termes, elle introduit une confusion sur la sémantique des ConceptScheme.
Est-ce un groupe de concepts, de termes ou bien de triplets ? 
Les étiquettes portent une seule chaîne lexicale avec les mêmes possibilités que pour SKOS grâce à l'attribut \cd{skos:literalForm}. 
L'indépendance des étiquettes permet également de spécifier des relations entre eux comme la synonymie, la traduction, etc. \cite{Pastor2009a}. 
Cette possibilité est ouverte par la relation générique \cd{skosxl:labelRelation}. 


% REVOIR les termes par rapport à l'exemple de SKOS
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
//====== CONCEPTS ======//
C-PlanAmericain rdf:type skos:Concept ; 
  skosxl:prefLabel <T-PlanAmericain> ;
  skosxl:prefLabel <T-AmericanShot> ;
  skosxl:altLabel <T-Plan34> ;
  skosxl:altLabel <T-MCShot> ;
  skos:example ex:PlanAmericain.png ;                               //Illustration//
  skos:definition "plan coupant les personnages à mi-cuisse"@fr ;   //Définition//
  skos:inScheme   <RTBF-Scheme> ;
  skos:inScheme   <AV-Scheme> ;
  skos:exactMatch <C-Plan34> .

C-Plan34 rdf:type skos:Concept ;
  skosxl:prefLabel <T-Plan34> ;
  skosxl:prefLabel <T-34Shot> ;
  skosxl:altLabel <T-MCShot> ;
  skosxl:hiddenLabel <T-MCS> ;                                           //Abréviations//
  skosxl:hiddenLabel <T-M-C-S> ;
  skos:example ex:PlanAmericain.png ;                                   //Illustration//
  skos:definition "shows a character from head to the middle of the leg"@en ;
  skos:inScheme <AV-Scheme> ;
  skos:inScheme <VRT-Scheme> .

//====== TERMES ======//
T-PlanAmericain rdf:type skosxl:Label ;
  skosxl:literalForm "Plan américain"@fr .
T-AmericanShot rdf:type skosxl:Label ;
  skosxl:literalForm "American shot"@en .
T-MCShot rdf:type skosxl:Label ;
  skosxl:literalForm "Medium-close shot"@en .
T-Plan34 rdf:type skosxl:Label ;
  skosxl:literalForm "Plan 3/4"@fr .
T-34Shot rdf:type skosxl:Label ;
  skosxl:literalForm "3/4 shot"@en .
T-MCS  rdf:type skosxl:Label ;
  skosxl:literalForm "mcs"@en .
T-M-C-S  rdf:type skosxl:Label ;
  skosxl:literalForm "m.c.s."@en .
\end{Verbatim}


Dans SKOS, la gestion de plusieurs jargons métiers dans une même conceptualisation [\e{A1 : multi-jargon}] est rendue difficile par la caractérisation simple des termes par la langue. 
Ainsi, même si on accroche plusieurs étiquettes au même concept, on ne sait pas les sélectionner pour les présenter à l'une ou l'autre communauté. 
Cela implique un dédoublement des concepts et donc des schémas conceptuels nécessaires (un par communauté).%, voir figure \ref{fig:skos}. 
%implique une représentation plus fine par rapport à SKOS ce qui 
Avec le découplage terme-concept de SKOS-XL, on peut gérer terme et concept de manière séparée sans pour autant avoir de primitives spécifiques pour regrouper les termes par jargon ou code d'écriture.%, voir figure \ref{fig:skosxl}. 
Une solution consisterait à regrouper les termes dans des ConceptScheme (SKOS-XL l'autorise).
Les ConceptScheme serviraient alors à la fois à regrouper les concepts (AV-Scheme) et les termes spécifiques aux organisations (RTBF-Scheme, VRT-Scheme). 
Cependant, si cette modélisation permet de gérer vocabulaire métier et conceptualisation de manière séparée c'est au prix d'un flottement sur la sémantique de ConceptScheme. 
Le support d'un nouveau jargon peut donc se faire sans toucher à la conceptualisation [\e{A3: gestion, évolution}] grâce à la permissivité de l'extension SKOS-XL. 
L'extension ou la mise en correspondance de la conceptualisation est facilitée par les relations sémantiques entre concepts.


\subsubsection{ISO 25964-1}
% \addcontentsline{toc}{subsubsection}{ISO 25964-1}
Cette norme propose une modélisation terme-concept similaire à SKOS-XL mais se concentre sur la représentation des thésaurus. 
Elle se fonde sur des modèles pré-existants, le méta-modèle de \cite{Vandenbussche2009} ainsi que la norme BS 8723. 
L'originalité par rapport à SKOS est de considérer la composition de termes ou de concepts et d'enrichir la description des éléments du modèle par des attributs Dublin Core.

Les termes se distinguent entre termes préférés simples ou composés et termes non préférés simples. 
La caractérisation des termes porte également sur l'appartenance à une langue à laquelle s'ajoutent des attributs de date, une définition ainsi que des notes d'historique et de révision. 
Des relations sémantiques entre termes sont également considérées en particulier l'équivalence composée, la synonymie, l'abréviation, l'acronyme, etc. 
Le thésaurus est considéré comme l'élément central décrit par l'ensemble des quinze attributs originaux du Dublin Core ainsi que des notes d'historique pour la maintenance. 
Sur les questions de documentation et de groupement de concepts, il existe une similarité importante avec les primitives de SKOS (note, groupe de concepts, etc.).\\

%\textbf{Discussion}\\
Les apports de la norme ISO 25964 par rapport à SKOS concernent davantage les pratiques de création et de maintenance de thésaurus que la gestion des jargons métiers [\e{A1 : multi-jargon}] et l'illustration de concepts par des ressources média [\e{A2 : documentation}]. 
Ainsi, les manques par rapport à nos besoins sont similaires. L'attention portée sur les détails de description de chaque élément du modèle est tout à fait convaincante. 
L'écart avec l'aspect épuré et synthétique de SKOS s'explique certainement par l'écart entre leurs objectifs. 
Alors que SKOS vise la publication de tout type de SOC, l'ISO 25946 se concentre sur la construction et l'évolution des seuls thésaurus. 
La norme ne s'est pas encore attelée aux questions d'interopérabilité et de correspondance avec d'autres vocabulaires. Ce travail est en cours et sera dévoilé dans la seconde partie de la norme (ISO 25946-2). 
De notre point de vue, il manque toujours un moyen de regrouper des termes indépendamment des concepts pour ajouter des jargons à une conceptualisation existante [\e{A3: gestion, évolution}].


% \subsection*{Bilan}



\subsubsection{Discussion (i)}
% \addcontentsline{toc}{subsection}{Discussion}
L'étude des standards et normes de références précédentes ne semble pas apporter de solution complètement satisfaisante pour l'ensemble de nos besoins. 
En effet, les approches restent centrées sur le concept et sa structuration auquel on intègre (SKOS) ou rattache (SKOS-XL, ISO 25946-1) ensuite les termes. 
Ces derniers sont représentés de manière plus ou moins fine (gestion des compositions dans ISO 25946 absente de SKOS). 
Dans tous les cas, la préférence d'un terme s'établit uniquement sur l'appartenance à une langue et non par rapport à une communauté de jargon. % mais sont caractérisés de manière identique dans les deux modèles (appartenance à une langue). 
De ce fait, ces modèles se limitent à représenter un seul jargon de référence par thésaurus et suppose ainsi l'existence d'une communauté homogène dans sa compréhension et dont on cherche à normaliser l'usage linguistique. %Dans notre cas, la collaboration entre communautés hétérogènes dans leur compréhension des concepts et leur utilisation de la langue exige de pouvoir gérer plusieurs jargons. C'est pourquoi 
% Nous proposons dans la suite un modèle Multi-Jargon afin d'associer plusieurs jargons métiers et des explications à une conceptualisation commune. %basé sur des concepts originaux 