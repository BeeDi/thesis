\newpage
\section{Langages de représentation}\label{sec:mods}
\e{
  L'objectif de cette section est de présenter des langages de représentation qui permettent de structurer des documents textuels (\ref{sec:xml}) et de construire des systèmes de connaissances (SOC).
  Nous nous intéressons à deux types de SOC, les ontologies (\ref{sec:ln-onto}) et les vocabulaires structurés de type thésaurus (\ref{sec:thesaurus}).
  La vision du W3C joue un rôle fondamental dans la définition de ces langages et leur adoption en tant que standards par l'industrie et les communautés scientifiques engagées dans ces questions.
  L'idée d'un Web Sémantique, proposée par \cite{Berners-Lee2001}, constitue une nouvelle étape dans la manipulation automatique des données sur le Web, qui ajoute à l'objectif de représentation des structures, la formalisation de leur sémantique :} 

  \gui{
    The Semantic Web is not a separate Web but an extension of the current one, in which information is given well-defined meaning, better enabling computers and people to work in cooperation.}

  \e{
  Ainsi, la formalisation des connaissances permet d'orienter la manipulation et la rendre signifiante dans le cadre d'activités humaines.
  Nous étudions ainsi le langage RDF qui fournit un moyen d'annoter les ressources sur le Web (\ref{sec:rdf}), tandis que RDF-Schema (\ref{sec:rdfs}) permet de spécifier le vocabulaire utilisé sous la forme d'ontologie légère.
  OWL propose des axiomes de représentations plus expressifs permettant de construire des ontologies lourdes (\ref{sec:owl}). }



% \subsection{Langages de balisages }
\subsection{XML}\label{sec:xml}
eXtended Markup Language (XML) est un langage de structuration hiérarchique de texte par balise qui facilite sa manipulation par les machines, tout en restant lisible par des humains.
XML est défini formellement comme un sous-ensemble du langage \pc{Standard Generalized Markup Language} (SGML), conçu pour améliorer l'efficacité des parseurs et l'échange d'information sur le Web.
Il est devenu une recommandation du W3C en 1998. 

% aims to give a hierarchical structure to  text in a machine-, yet human-readable way. It is widely used to store or exchange information as it also supports Unicode.
% XML is formally defined as a Standard Generalized Markup Language's subset (SGML) designed to improve parser efficiency. Work on XML began in 1996 and it became a W3C Recommendation in early 1998.

\paragraph{Syntaxe}
Le balisage permet de créer des éléments qui encadrent du texte, de ce fait l'identifie et facilite ainsi sa manipulation.
Des attributs peuvent être ajoutés aux élements afin de donner une information sur leur contenu, sous la forme \cd{att1='val1'} séparés par des virgules.
Par exemple, \cd{xml:lang} permet de spécifier quel langage naturel a été utilisé pour écrire le texte encadré.
XML permet de plus d'imbriquer des éléments afin de créer une structure d'arbre représentant la structure dite \e{logique} ou \e{canonique} du document.
L'exemple suivant propose une synthèse de la syntaxe proposée par XML, en définissant l'élémént \cd{film} composé d'un sous-élément \cd{titre}.
Dans cet exemple, il s'agit de décrire le film \gui{Hook ou la revanche du capitaine Crochet}, mais en donnant le titre du film en Russe :
% This is achieved by adding mark-up elements that are easily noticed as they begin with '<' and end with a '>'. Mark-up elements are used to enclose unicode text, and give thus a mean to identify them and possibly to process it. As its name indicates, it is said extensible because we can define our own mark-up elements and writes a line like that:
% opening mark-up element       enclosing mark-up element
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<film>
  <titre xml:lang='ru'>Капитан Крюк</titre>
</film>
\end{Verbatim}

% Attributes can be defined for each mark-up element. 
% For instance, the xml:lang attributes indicates the natural language used to write the enclosed text. The \gui{1812 Overture} full title can be written like that:
% \begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
% <title xml:lang='ru'>Торжественная увертюра 1812 года, Toržestvennaja uvertjura 1812 goda</title>
% <title xml:lang='fr'>Ouverture Solennelle, L'Année 1812, Op. 49</title>
% \end{Verbatim}

% \paragraph{Syntax}
% XML does not only enclose text with mark-up elements. It also enables to imbricate mark-up elements in such a way that the elements conforms to a tree structure. 

% \begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
% <element>
% 	<sub-element>Example of text</sub-element>
% </element>
% \end{Verbatim}

% Other syntaxic rules have been defined to enables conforming parser to process XML file. Any file conspuing to these rules is said to be well-formed.

\paragraph{Schéma}
En plus de la syntaxe fournit par XML, il existe de nombreux langages de schéma\footnote{Nous citerons \gui{Document Type Defintion} (DTD) qui est très simple à prendre en main, mais peu expressif comparé à \gui{XML Schema} et \gui{Relax NG}.} qui permettent de modéliser des documents et de fournir des grammaires de structuration.
Ces schémas définissent des contraintes sur la structure des éléments, les attributs et les types de valeurs que l'on peut utiliser.
Un fichier XML qui se conforme aux contraintes d'un schéma particulier est dit \e{valide}.
Il existe donc deux types de contraintes pour les documents XML utilisant un schéma, la syntaxe de XML (qui les rend \e{bien formés}) et le schéma (qui les rend \e{valides}).

% XML permet également de créer
% Furthermore, if XML provides us with a syntax we also have the ability to makes purpose-specific XML-based mark-up languages – i.e. define constraints on structure, mark-up elements or even datatyping definition. Indeed, several schema languages exists and are used to encode documents or serialize text data according to a particular schema. XML files complying with a schema – i.e. conforming to the constraints defined in the schema – are said to be valid.


\paragraph{Espace de nom}
La création de schémas peut aboutir à des problèmes d'ambiguïtés entre des éléments homonymes. 
La définition d'un espace de nom (Namespace) permet de gérer ce problème en ajoutant un préfixe à chaque élément et attribut.
L'espace de nom propose ainsi un espace abstrait, identifié par une URI, qui résoud les problèmatiques de nommage d'éléments et permet ainsi de garder les spécificités de chacun des homonymes. 
On peut donc par exemple, redéfinir l'élément \cd{title} du Dublin Core en lui ajoutant le préfixe \cd{ex} correspondant à l'URI \cd{http://example.org} : 

% When creating schemas, ambiguity problems usually arise and namespace declaration can take care of that. Indeed, it provides an abstract container for XML elements and attributes and gives to their name a scope. As each namespace is identified by an URI, the ambiguity between identically named elements or attributes from differents namespace can be resolved. 

% Therefore, I can declare my own \gui{title} element and simultaniously use the \gui{DC Terms} property title. We show here a complete example with xml heading:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<?xml version="1.0" encoding="UTF-8"?>
<ex:racine xmlns:dc="http://purl.org/dc/elements/1.1/"
    			 xmlns:ex="http://example.org">
	<dc:title>Hook</dc:title>
  <ex:title>Hook ou la revanche du capitaine Crochet</ex:title>
</ex:racine>
\end{Verbatim}
Dans cet exemple, dc:title correspond à l'élément désignant le titre courant, et ex:title correspond à l'élément désignant le titre long.


\subsubsection*{XML Schema}
Cette recommandation du W3C a été publiée en 2001, comme l'un des langages de schéma développé pour XML \parcite{Thompson2004}.
Souvent appellé XSD en référence à son suffixe de fichier '.xsd', le langage offre de nombreuses fonctionnalités : 
\begin{liste}
  \item Déclarer des imbrications (ordre et hiérarchie), des quantifications et des règles de nommage pour les éléments et attributs XML.
  \item Réutiliser des parties d'autres schémas grâce aux espaces de noms.
  \item Distinguer entre type simple (pas d'élément, ni d'attribut) ou des types complexes.
  \item La déclaration de types dérivés, en définissant des restrictions sur des types existants.
\end{liste}
% This W3C recommendation was published in 2001 and is one of several xml schema languages\footnote{We can cite, the old and very simple \gui{Document Type Defintion}(DTD) as well as the major rival of XML Schema, namely \gui{Relax NG}.}. It is often called XSD in reference to its files suffix – '.xsd'.

% XSD can define imbrication, quantification and naming rules for xml elements and attributes – in order to enable vocabulary and content model validation. XSD also supports namespace so parts of other schemas can be included or imported. 

\paragraph{Type de données}
Une des principales caractéristiques de XSD, et aussi une des plus critiquées, est l'utilisation de types de données (Datatype), qui peut s'appliquer sur les éléments ou les attributs pour contraindre le champ de valeur possible \parcite{Biron2004}.
Le problème soulevé étant que cette restriction ne peut se déclarer qu'à partir de la définition d'un type de données, soit par restriction, par liste de valeurs possibles, ou bien par union entre différents types de données.

% But one of the main and most criticized characteristic of XSD is DataType validation.
% It can be applied to elements or attributes to constraint their content.  DataType definition must use XSD primitive or derived datatypes – see the scheme for a detailled hierarchy. This dependence upon specific datatypes is the source of many criticism. 

% Derived datatypes can be built by restriction – of the permitted values set –, list – declaration of values –, or union – between several types. 
% As an complete example, we define a XSD schema describing \gui{MusicalOpus} as a list of XML elements named:
Voici un exemple de schéma XSD décrivant sommairement un film par une liste d'éléments XML : 
\begin{liste}
	\item Title: titre du film
	% \item Extent: length or duration – as a string
	\item Director: nom du réalisateur
	\item released: date de sortie du film (seulement l'année)
	% \item Performer: name of the performer
	% \item performed: date of performance – only the year
	\item writtenBy: nom de la personne ayant écrit une oeuvre dont le film propose une adaptation (attribut optionnel)
	\item DirectorNationality: nationalité du réalisateur (à partir d'une liste de valeur)
\end{liste}

Voilà le schéma XSD pour la description d'un Film:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<?xml version="1.0" encoding="utf-8"?> 
<xs:schema elementFormDefault="qualified"   xmlns:xs="http://www.w3.org/2001/XMLSchema"> 
 <xs:element name="Film"> 
   <xs:complexType> 
     <xs:sequence> 
       <xs:element name="Title" type="xs:string" /> 
       <xs:element name="Director" type="xs:string" /> 
       <xs:element name="released" type="xs:gYear" /> 
       <xs:element name="writtenBy" type="xs:string" minOccurs="0"/>  
       <xs:element name="DirectorNationality"> 
         <xs:simpleType> 
           <xs:restriction base="xs:string"> 
             <xs:enumeration value="FR" /> 
             <xs:enumeration value="DE" /> 
             <xs:enumeration value="RU" /> 
             <xs:enumeration value="UK" /> 
             <xs:enumeration value="US" /> 
           </xs:restriction> 
         </xs:simpleType> 
       </xs:element> 
     </xs:sequence> 
   </xs:complexType> 
 </xs:element> 
</xs:schema> 
\end{Verbatim}
       % <xs:element name="Performer" type="xs:string" /> 
       % <xs:element name="performed" type="xs:gYear"/> 
% <xs:element name="Extent" type="xs:string" /> 

Voici un exemple de fichier XML dont le contenu est valide par rapport au schéma XSD précédent, le lien étant fait par l'attribut \cd{xsi:noNamespaceSchemaLocation} :
% And we provide a XML file which states that it conforms to the previous XSD scheme through a xsi:noNamespaceSchemaLocation attribute:
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<?xml version="1.0" encoding="utf-8"?> 
<Film xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:noNamespaceSchemaLocation="Film.xsd"> 
  <Title>Hook ou la vengeance du capitaine Crochet</Title> 
  <Director>Steven Spielberg</Director> 
  <released>1991</released> 
  <writtenBy>James Matthew Barrie</conductedBy> 
  <DirectorNationality>US</DirectorNationality> 
</Film> 
\end{Verbatim}
%   <Extent>14:19</Extent>      
% <Performer>Minneapolis Symphony Orchestra</Performer> 
%   <performed>1954</performed> 














\subsection{Ontologie et modèle conceptuel}\label{sec:onto-mc}\label{sec:ln-onto}
\subsubsection{Resource Description Framework}\label{sec:rdf}
% \addcontentsline{toc}{subsubsection}{Resource Description Framework}
RDF est un modèle de graphe développé par le W3C \parcite{Manola2004}.
Il permet d'annoter et de relier des ressources sur le Web, de manière à les rendre manipulable par des agents logiciels.
Pour faciliter l'exploitation de ces ressources, RDF est doté d'une sémantique formelle propice à la réalisation d'inférences.

% The Resource  Description Framework (RDF) is an abstract model which is part of the W3C recommendations for the Semantic Web. 
% Let's just bring back to mind how \pc{Tim Berners-Lee} defined it to set RDF back into its context of creation: 

% \ciel{
% The Semantic Web is not a separate Web but an extension of the current one, in which information is given well-defined meaning, better enabling computers and people to work in cooperation.}

% Indeed, RDF aims to describe and link resources – and no more web pages – in a simple, all-purpose and machine-readable way. 
% The focus on software agents led to choose a formal semantic and provable inference. 
% Thus, such descriptions will foremost benefits to software agents which we'll be able to exploit, process and search into this web of linked data. 

\paragraph{Syntaxe}
L'annotation des ressources consiste à écrire des assertions sous la forme \e{Sujet --Prédicat--> Objet}.
Les sujets sont les ressources à annoter, les objets peuvent être soit une ressource, soit une valeur littérale.
Plusieurs assertions forment un graphe orienté dans lequel chaque \e{sujet/objet} est un noeud, et les prédicats (propriétés) sont des liens étiquettés.
RDF utilise les URI pour identifier ces ressources, propriétés et des valeurs littérales typées (par exemple, grâce aux types XSD).
RDF peut utiliser plusieurs types de sérialisations, comme RDF/XML, ou bien la Notation3 (N3).

L'exemple suivant annote la page Wikipédia du film \ciel{Hook} en précisant sa date de réalisation. L'annotation utilise des préfixes d'URI et une entité XML pour simplifier l'écriture de l'URI du type de données \cd{gYear} de XSD : 
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
<?xml version="1.0"?>
<!DOCTYPE rdf:RDF [<!ENTITY xsd "http://www.w3.org/2001/XMLSchema#">]>
<rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:ex="http://example.org">
        <rdf:Description rdf:about="https://fr.wikipedia.org/wiki/Hook_ou_la_Revanche_du_capitaine_Crochet">
                <ex:released rdf:datatype="&xsd;gYear">1991</ex:released>
        </rdf:Description>
</rdf:RDF>
\end{Verbatim}

\paragraph{Grouper des ressources}
Lorsqu'une même ressource est le sujet de plusieurs assertions, la syntaxe de RDF nous impose de créer des noeuds intermédiaires (\e{blank node}).
De ce fait, ces noeuds ne sont pas référencés par une URI, mais utilise un système d'identification propre.

Ces groupes de ressources peuvent être typés pour définir la manière dont ses membres sont organisés.
Le type \cd{Collection} permet de définir des groupes clos (seul les membres cités sont compris dans le groupe), alors que le type \cd{Container} ne permet pas de clôturer l'appartenance à un groupe.
Ce dernier type propose trois sous-types qui organisent leurs membres de manière distincte : 

\begin{liste}
  \item Un sac (\cd{bag}) est un groupe non-ordonné qui peut contenir des doublons.
  \item Une séquence (\cd{seq}) est un groupe ordonné qui peut contenir des doublons. 
  \item Un type alternatif (\cd{alt}) est un groupe de valeur littérale ou de ressources alternatives.
\end{liste}

Par exemple, on peut déclarer une liste de noms alternatifs pour le titre du film \e{Hook} en utilisant le type \cd{alt} (anglais, français et le titre français du Canada) :
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
wk:Hook         -- ex:Name -->    _blank_node_01
_blank_node_01  -- rdf:type -->   rdf:alt
_blank_node_01  -- rdf:li -->     'Hook' @en 
_blank_node_01  -- rdf:li -->     'Hook ou la Revanche du capitaine Crochet' @fr
_blank_node_01  -- rdf:li -->     'Capitaine Crochet' @fr-ca
\end{Verbatim}


\begin{table}[ht!]
   \begin{center}
    \begin{tabularx}{\textwidth}{|l|X|}
       \hline
    \gpc{Nom de la classe} & \gpc{Définition}\\ \hline\hline
    \cd{rdf:Statement} & La classe des assertions RDF.\\ \hline
    \cd{rdfs:Resource} & La classe de toute les ressources.\\ \hline
    \cd{rdfs:Class} & La classe de toutes les classes.\\ \hline
    \cd{rdf:Property} & La classe des propriétés RDF.\\ \hline
    \cd{rdfs:Literal} & La classe des valeurs littérales, chaîne de caractères, entiers etc.\\ \hline
    \cd{rdf:XMLLiteral} & La classe des valeurs littérales en XML.\\ \hline
    \cd{rdfs:Datatype} & La classe des types de données RDF.\\ \hline
    \cd{rdfs:Container} & The class of RDF containers.\\ \hline
    \cd{rdfs:ContainerMembershipProperty} & La classe container des propriétés d'appartenance à une groupe.\\ \hline
    \cd{rdf:Bag} & La classes container avec membres non-ordonnés.\\ \hline
    \cd{rdf:Seq} & La classes container avec membres ordonnés.\\ \hline
    \cd{rdf:Alt} & La classes container  avec membres alternatifs.\\ \hline
    \cd{rdf:List} & La classe des listes RDF.\\ \hline
    \end{tabularx}
    \caption{Liste des classes introduites par RDFS\label{tab:rdfs-classes}}
   \end{center}
\end{table}


\subsubsection{RDF Schema}\label{sec:rdfs}
% \addcontentsline{toc}{subsubsection}{RDF Schema}
RDFS a été développé pendant 6 ans par des groupes de travail du W3C, pour devenir une recommandation \parcite{Brickley2004}.
RDFS est un language permettant de définir des vocabulaires de descriptions de ressources, proche des ontologies.
Comme RDF, RDFS suit une approche minimaliste qui réduit l'expressivité du langage pour faciliter son exploitation, contrairement à OWL qui lui rajoute certains raffinements.

\paragraph{Ressource, Classe, Propriété}
RDFS définit des classes de ressources (voir la Table \ref{tab:rdfs-classes}), identifiés par des URI, décrits par des propriétés (voir la Table \ref{tab:rdfs-properties}) et associés avec un ensemble d'instances (l'extension de la classe). 
Les classes, comme les propriétés, sont hiérarchisées par la primitive \cd{rdfs:subClassOf} (\cd{subPropertyOf} pour les propriétés).
Une des particularités de \cd{rdfs:class}, comme de \cd{rdfs:property}, est de s'accepter comme des instances, ce qui explique leur présence dans la liste des classes et de propriétés.

Les propriétés définissent des liens entre ressources, l'une étant le sujet de l'assertion, l'autre l'objet.
La déclaration des propriétés utilise les propriétés \cd{rdfs:domain} et \cd{rdfs:range} pour contraindre la classe de ressources pouvant être utilisée comme sujet (le domaine) et objet d'une assertion (la portée).
Remarquons également que les propriétés suivantes correspondent plus à une documentation des vocabulaires construits par RDFS, qu'à une anntotation de ressources : \cd{rdfs:label}, \cd{rdfs:comment}, \cd{rdfs:seeAlso}, \cd{rdfs:isDefinedBy}.



% 7.3.2.a  Property List
\begin{table}[ht!]
   % \begin{center}
		\begin{tabularx}{450pt}{|l|X|r|l|}
		   \hline 
       \gpc{Nom de la propriété} & \gpc{Définition} & \gpc{Domaine} & \gpc{Portée} \\ \hline\hline
\cd{rdf:type} & Le sujet est une instance de la classe. & \cd{rdfs:Resource} & \cd{rdfs:Class} \\ \hline
\cd{rdfs:subClassOf} & Le sujet est une sous-classe de la classe. & \cd{rdfs:Class} & \cd{rdfs:Class} \\ \hline
\cd{rdfs:subPropertyOf} & Le sujet est une sous-propriété de la propriété. & \cd{rdf:Property} &\cd{rdf:Property} \\ \hline
\cd{rdfs:domain} & Le domaine d'une propriété (la classe de ressources pouvant être sujet). & \cd{rdf:Property} & \cd{rdfs:Class}\\ \hline
\cd{rdfs:range} & La portée d'une propriété (la classe de ressources pouvant être objet) & \cd{rdf:Property} & \cd{rdfs:Class}\\ \hline
\cd{rdfs:label} & Une étiquette lisible par des humains. & \cd{rdfs:Resource} & \cd{rdfs:Literal} \\ \hline
\cd{rdfs:comment} & Une description de la ressource sujet. & \cd{rdfs:Resource} & \cd{rdfs:Literal}\\ \hline
\cd{rdfs:member} & Une ressource membre de la ressource sujet. & \cd{rdfs:Resource} & \cd{rdfs:Resource}\\ \hline
\cd{rdf:first} & Le premier élémént d'une liste RDF. & \cd{rdf:List} & \cd{rdfs:Resource}\\ \hline
\cd{rdf:rest} & Le reste d'une liste RDF (les éléments après le premier). & \cd{rdf:List} & \cd{rdf:List}\\ \hline
\cd{rdfs:seeAlso} & Des informations complémentaires sur le sujet. & \cd{rdfs:Resource} &\cd{rdfs:Resource}\\ \hline
\cd{rdfs:isDefinedBy} & La définition de la ressource sujet. & \cd{rdfs:Resource} & \cd{rdfs:Resource}\\ \hline
\cd{rdf:value} & Propriété idiomatique utilisée pour la définition de valeurs structurés (Container etc.) & \cd{rdfs:Resource} & \cd{rdfs:Resource}\\ \hline
\cd{rdf:subject} & Le sujet d'une assertion RDF. & \cd{rdf:Statement} & \cd{rdfs:Resource}\\ \hline
\cd{rdf:predicate} & Le prédicat (propriété) d'une assertion RDF. & \cd{rdf:Statement} & \cd{rdfs:Resource}\\ \hline
\cd{rdf:object} & L'objet d'une assertion RDF. & \cd{rdf:Statement} & \cd{rdfs:Resource}\\ \hline
		\end{tabularx}
		\caption{Class list \label{tab:rdfs-properties}}
   % \end{center}
\end{table}

% Eventually, observe these four properties that appear more like annotation than property defining resource: \cd{rdfs:label}, \cd{rdfs:comment}, \cd{rdfs:seeAlso}, \cd{rdfs:isDefinedBy}.





\subsubsection{Ontology Web Language}\label{sec:owl}
% \addcontentsline{toc}{subsubsection}{Ontology Web Language}
OWL est un langage de représentation des connaissances visant à construire des ontologies pour le Web \parcite{Bechhofer2004}.
Le travail sur le langage a débuté en 2001 à partir des travaux sur DAML+OIL initiés conjointement par le \pc{Defense Advanced Research Projects Agency} (DARPA) et le le projet \pc{Information Society Technologies} (IST) de l'Union Européenne \parcite{Connolly2001}.

OWL repose sur RDF et une syntaxe XML et définit ses primitives par extension des classes et propriétés RDF/RDFS, notamment en ajoutant des contraintes de cardinalité ou de comparaison sur les déclarations de classes et de propriétés.
En comparaison de RDF/RDFS, dont la sémantique se rapproche de celle des graphes conceptuels, OWL est doté d'une sémantique en logique de description.
OWL permet ainsi de développer des ontologies informatiques exploitables par des outils de raisonnement.
Cependant, afin de couvrir un plus grand nombre de cas d'usage, OWL définit trois sous-langages dont l'expressivité, et donc l'efficacité computationnelle, varie. 
Chaque sous-langage est un sous-ensemble de ses prédécesseurs, ce qui implique que toute représentation en \pc{OWL Lite} est valide en \pc{OWL-DL}, et de même entre \pc{OWL-DL} et \pc{OWL Full}.

\begin{liste}
  \item \pc{OWL Full} a été conçu comme un sur-ensemble de RDF/RDFS de manière à être le plus compatible avec lui, au prix de la décidabilité.
  Par exemple, \pc{OWL Full} est la seule version de OWL qui accepte que tout élément d'une ontologie soit considéré comme un individu (même pour les classes et les propriétés).

  \item OWL-DL dispose des mêmes primitives que \pc{OWL Full}, mais leur usage est plus contraint de manière à assurer complétude computationnelle (toutes les inférences sont calculables) et décidabilité (tous les calculs finissent en un temps fini).

	\item \pc{OWL Lite} est le plus simple, le moins expressif des sous-langage.
  Il a été conçu pour formaliser des ontologies peu complexe et favoriser la vitesse de raisonnement.	
\end{liste}
% Each level is a sub-level from its predecessor, that is every legal ontology or valid conclusion expressed in \gui{OWL Lite} is a legal ontology or respectively a valid conclusion in \gui{OWL-DL} and so on between \gui{OWL-DL} and \gui{OWL Full}. 

Une ontologie OWL est un ensemble \e{classes} et de \e{propriétés} organisé hiérarchiquement et éventuellement associé à une base de faits, c'est-à-dire des \e{instances} de ces classes et des assertions les reliant.
La Table \ref{tab:owl-class} présente l'ensemble des axiomes s'appliquant aux classes OWL. 
Les cases en gris clair indiquent les axiomes qui s'appliquent à \pc{OWL Lite} sous conditions, et les cases en gris foncé, les axiomes qui ne sont pas disponibles dans \pc{OWL Lite} (mais bien dans OWL-DL et \pc{OWL Full}).
On distingue en particulier, les axiomes qui permettent de déclarer une nouvelle classe, éventuellement en apposant des restrictions ou en combinant d'autres classes, de ceux qui participent à sa définition, notamment en rapport avec les autres classes de l'ontologie.
À cela, il faut ajouter l'axiome RDFS \cd{rdfs:subClassOf}.
% Il est important de noter que toutes les classes sont des sous-classe de la superclasse \cd{owl:Thing}.


\begin{table}[ht!]
    \begin{tabularx}{\textwidth}{|p{3cm}|X|r|}
       \hline
     \multicolumn{2}{|X|}{\gpc{Axiomes de déclaration de classe}} & \gpc{Primitive}\\ \hline\hline
    
    \multicolumn{2}{|p{11cm}|}{\e{Déclaration simple} en utilisant une URI.} & \cd{owl:class} \\ \hline
    
    \rowcolor{lightgray} 
    \multicolumn{2}{|p{11cm}|}{\e{Déclaration par énumération} exhaustive de l'extension de classe (instance), par exemple en utilisant les primitives RDFS de groupage.} & \cd{owl:oneOf} \\ \hline
    

    \multirow{3}{3cm}{\e{Combinaison booléenne}} & opérateur logique AND & \cd{owl:intersectionOf}  \\ \cline{2-3}
    & opérateur logique OR & \cellcolor{lightgray} \cd{owl:unionOf}  \\ \cline{2-3}
    & opérateur logique NOT & \cellcolor{lightgray} \cd{owl:complementOf} \\ \hline
    

    \multirow{7}{3cm}{\e{Restriction sur les propriétés}} & \multirow{2}{8cm}{en désignant une classe (\pc{OWL Lite}) ou bien un types de données} & \cellcolor{black!10} \cd{owl:allValuesFrom} \\ \cline{3-3}
    & & \cd{owl:someValuesFrom} \\ \cline{2-3}
    & en désignant des instances ou des valeurs littérales & \cellcolor{lightgray} \cd{owl:hasValue} \\ \cline{2-3}
    & \multirow{3}{8cm}{en définissant des cardinalités (0..1 pour \pc{OWL Lite})}
    & \cellcolor{black!10} \cd{owl:maxCardinality} \\ \cline{3-3}
    & & \cellcolor{black!10} \cd{owl:minCardinality} \\ \cline{3-3}
    & & \cellcolor{black!10} \cd{owl:cardinality} \\ \hline\hline


    \multicolumn{2}{|X|}{\gpc{Axiomes de définition de classe}} & \gpc{Primitive}\\ \hline\hline
    \multicolumn{2}{|p{11cm}|}{\e{Spécialisation} en désignant une classe mère dont l'extension contient l'extension de la classe fille.} & \cd{owl:subClassOf}\\ \hline
    \multicolumn{2}{|p{11cm}|}{\e{Équivalence} entre classes (extension équivalente)} & \cd{owl:equivalentClass}\\ \hline
    \multicolumn{2}{|p{11cm}|}{\e{Disjonction} entre les extensions de classes} & \cellcolor{lightgray} \cd{owl:disjointWith}\\ \hline

    \end{tabularx}
    \caption{Axiomes de classe en OWL\label{tab:owl-class}}
\end{table}

OWL distingue quatre types de propriétés, qui doivent être mutuellement disjointes lorsqu'on utilise OWL-DL :
\begin{liste}
	\item \cd{owl:DatatypeProperty} associe des valeurs littérales à une instance.
	\item \cd{owl:ObjectProperty} définit des relations entre des instances.
	\item \cd{owl:AnnotationProperty} associe n'importe quelle valeur ou ressource à une instance dans un but de documentation de l'ontologie. 
  En effet, ces propriétés ne seront pas traités par les raisonneurs.
  En OWL-DL, il est impossible de définir des restrictions ou des spécialisations sur ces propriétés.
	\item \cd{owl:OntologyProperty} est utilisée pour l'importation d'ontologie et documenter le développement (par version) de l'ontologie.
	En OWL-DL, ces propriétés partagent les mêmes contraintes que les propriétés d'annotation.
\end{liste}

Ces propriétés sont définies par l'intermédiaire d'axiomes RDFS, pour déclarer le domaine (\cd{rdfs:domain}) et la portée (\cd{rdfs:range}) ou encore une propriété mère (\cd{rdfs:subPropertyOf}).
À cela, OWL ajoute des axiomes permettant d'établir l'équivalence entre deux propriétés (\cd{owl:equivalentProperty}) ainsi que d'autres propriétés algébriques qui affine la formalisation des définitions : 
\begin{liste}
  \item \cd{owl:TransitiveProperty}: P(X,Y) et P(Y,Z) implique P(X,Z). 
  Par eXemple, si X est près de Y et Y est près de Z, alors X est près de Z.
  \item \cd{owl:SymetricProperty}: P(X,Y) si et seulement si (ssi) P(Y,X).Si X est près de Y, alors Y doit être près de X.
  \item \cd{owl:FunctionalProperty}: P(X,Y) et P(X,Z) implique Y = Z. 
  La propriété possède une seule valeur pour chaque individu sur laquelle elle s'applique.
  \item \cd{owl:InverseFunctionalProperty}: P(Y,X) et P(Z,X) implique Y = Z.
  \item \cd{owl:InverseOf}: P1(X,Y) ssi P2(Y,X). 
  Si X est pèreDe Y, alors Y est filsDe X, donc les propriétés pèreDe et filsDe sont inverses.
\end{liste}

Les propriétés d'annotation utilisées sont celles de RDFS, plus la propriété \cd{owl:versionInfo} qui permet de documenter la version actuelle de l'ontologie.
Les propriétés d'ontologies (\cd{owl:priorVersion}, \cd{owl:backwardCompatibleWith}, \cd{owl:incompatibleWith}) permettent de documenter l'ontologie en précisant sa relation avec d'autres versions (représentées par des instances de instance de \cd{owl:Ontology}).
Les propriétés \cd{owl:DeprecatedClass} et \cd{owl:DeprecatedProperty} désignent les classes ou propriétés qui sont maintenues dans l'ontologie pour des raisons de compatibilité, mais ne sont pas susceptibles d'être utilisées dans les futures versions.

% \paragraph{Property declaration}
% We take as an example the definition of creation relationships on two different level of specialisation. 
% First, a \gui{createdBy} relation between a \gui{Person} and an \gui{Opus}. 
% Second, a music related \gui{composedBy} relation, involving a \gui{Composer} and a \gui{MusicalOpus}.

% Class declaration:
% \begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
% <owl:Class rdf:ID='Composer'>
% 	<rdfs:subClassOf rdf:resource='Person' />
% </owl:Class>
% <owl:Class rdf:ID='Opus' />
% <owl:Class rdf:ID='MusicalOpus'>
% 	<rdfs:subClassOf rdf:resource='Opus' />
% </ow:Class>
% \end{Verbatim}

% Property declaration:
% \begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
% <owl:ObjectProperty rdf:ID='createdBy'>
% 	<rdfs:domain rdf:resource='Opus' />
% 	<rdfs:range rdf:resource='Person' />
% </owl:ObjectProperty>
% <owl:ObjectProperty rdf:ID='composedBy'>
% 	<rdfs:domain rdf:resource='MusicalOpus' />
% 	<rdfs:range rdf:resource='Composer' />
% 	<rdfs:subPropertyOf rdf:resource='createdBy />
% </owl:ObjectProperty>
% \end{Verbatim}
% Note the use of rdfs:domain, rdfs:range, rdfs:subPropertyOf and rdfs:subClassOf properties within OWL statements.

% Now, if we want to take advantage of Property restrictions to define our \gui{Composer} class, we can state for instance that \gui{Composer} individuals are precisely those \gui{Person} individuals who have \gui{composed} at least one \gui{MusicalOpus}. 
% This lead us to write the following declaration: 
% \begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
% <owl:Class rdf:ID='Composer'>
%   <rdfs:subClassOf>
%     <owl:intersectionOf rdf:parseType='Collection'>
%       <owl:Class rdf:ID='Person' />
%       <owl:Restriction>
%         <owl:onProperty rdf:resource='composedBy' />
%         <owl:minCardinality rdf:datatype='\&xsd;nonNegativeInteger'>1</owl:minCardinality>
%       </owl:Restriction>
%     </owl:intersectionOf >
%   </rdfs:subClassOf>	
% </owl:Class>
% \end{Verbatim}
% Note that the intersectionOf property requires a list of Classes declarations which can be given either by owl:Class or owl:Restriction – which is defined as a sub-class of owl:Class. 


% \paragraph{Individual}
Les ontologies OWL peuvent également contenir des individus, c'est-à-dire des instances de classes, décrits par l'usage de propriétés.
Ces individus sont identifiés par des URI, comme dans RDF/RDFS. 
Trois axiomes OWL permettent de définir des individus par leurs relations aux autres : 
\begin{liste}
  \item \cd{owl:sameAs} déclare deux URI comme faisant référence au même individu, permettant ainsi de fusionner leur définition et les conclusions qu'on a pu en tirer.
  \item \cd{owl:differentFrom} déclare explicitement deux URI comme se référant à des individus distincts.
  \item \cd{owl:AllDifferent} permet de déclarer que tous les individus d'une liste sont distincts.
\end{liste}
% Ontology is not only about Classes and Properties, it enables us to state some facts about individuals. In order to describe them, we state them as Class instance, make use of Property or assert facts about their individuality. 
% Let's use our previous ontology description to decribe \gui{Tchaikovsky} and the \gui{1812 overture}.
% \begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
% <Person rdf:ID='Tchaikovsky' />
% <MusicalOpus rdf:ID='1812_Overture'>
% 	<composedBy rd:resource='Tchaikovsky' />
% </MusicalOpus>
% \end{Verbatim}

% From this description, we can entail that:
% \gui{Tchaikovsky} is not only a \gui{Person}, it is also a \gui{Composer} because he composed the \gui{1812 overture}. As he composed it, we can also say that he has \gui{created} it. 

% As OWL is a web language, it has rejected the \gui{unique name} assumption and hence need to deal with identity uniqueness – and thus URI reference. In order to do so, three constructs have been defined:
 



% Now, to demonstrate the use of sameAs property and to refer to our information sample, we define several \gui{Tchaikovsky} individuals with different spelling. Then, we declare several MusicalOpus, \gui{Cappricio italien} and «\verb?Ромео и Джульетта?» which is the russian spelling for \gui{Romeo and Juliet}.

% \begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
% <Person rdf:ID='Tchaïkovski' xml:lang='fr' />
% <Person rdf:ID='Чайкoвский' xml:lang='ru' />

% <MusicalOpus rdf:ID='Capriccio_italien' xml:lang='fr'>
% 	<composedBy rd:resource='Tchaïkovski' />
% </MusicalOpus>
% <MusicalOpus rdf:ID='Ромео и Джульетта' xml:lang='ru'>
% 	<composedBy rd:resource='Чайкoвский' />
% </MusicalOpus>
% \end{Verbatim}
% If we change the first statements by:
% \begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
% <Person rdf:ID='Tchaïkovski' xml:lang='fr'>
% 	<owl:sameAs rdf:resource='Tchaikovsky'/>
% </Person>
% <Person rdf:ID='Чайкoвский' xml:lang='ru'>
% 	<owl:sameAs rdf:resource='Tchaikovsky'/>
% </Person>
% \end{Verbatim}
% We can entail that there are the same person and that he has composed all three \gui{MusicalOpus} described. 





\paragraph{Discussion}
OWL, notamment dans ces versions OWL-DL et \pc{OWL Full} enrichit fortement l'expressivité des modélisations par rapport à RDF/RDFS, notamment du fait des définitions de propriétés avec des propriétés algébriques, et de la déclaration de classes par ajout de restrictions ou de combinaisons booléenne.
Les primitives de OWL permettent de documenter les concepts a minima, grâce à l'apposition d'étiquettes multilingues, à l'ajout de définition et au renvoi vers des ressources externes [\g{$\delta_2$ : documentation}]. 
Les propriétés d'ontologie permettent de documenter son évolution et faciliter sa prise en main par ses utilisateurs.
De plus, la possibilité d'importer des ontologies et d'utiliser des espaces de noms (via les URI) permet l'intégration d'autres ontologies, qu'on peut ensuite aligner pour fusionner les connaissances [\g{$\delta_3$ : gestion, évolution}].
Pour autant, OWL ne permet pas d'associer un thésaurus multi-jargon à la conceptualisation modélisée, car les étiquettes sont des valeurs littérales, et non des objets que l'on peut organiser hiérarchiquement [\g{$\delta_1$ : multi-jargon}].
De ce fait, OWL n'est pas suffisant pour satisfaire à tous nos besoins de modélisations (\ref{sec:bm}).
La section suivante examine donc des formalismes de représentation de vocabulaire structuré.
L'objectif étant de pouvoir représenter l'ontologie en OWL et d'intégrer des vocabulaires à cette ontologie via un autre formalisme.








\subsection{Thésaurus et vocabulaire structuré}\label{sec:thesaurus}
\subsubsection{Simple Knowledge Organization System}\label{sec:skos}
% \addcontentsline{toc}{subsubsection}{Simple Knowledge Organization System}
\e{
SKOS est un langage de représentation de vocabulaires structurés et de thésaurus qui repose sur RDF et OWL. 
Son objectif est de représenter tout type de SOC en vue de le publier sur le web de données,  liées et ouvertes (Linked Open Data). 
En témoigne les travaux et méthodes de conversion proposés par \cite{Summers2008} ou \cite{VanAssem2006} et les applications de gestion de thésaurus développés autour de SKOS, comme celle de \cite{Schandl2010}.
On notera que l'objectif de publication semble pousser vers une représentation minimale mais extensible de SOC déjà construits.
}

\paragraph{Concept et Etiquette}
SKOS centre son modèle sur les concepts (\cd{skos:Concept}) et considère les étiquettes comme des propriétés de ces derniers. 
On distingue trois types d'étiquettes: 
\begin{liste} 
	\item Les étiquettes préférées (\cd{skos:prefLabel}) qui sont uniques par langue et servent de référence.
	\item Les étiquettes alternatives (\cd{skos:altLabel}) qui servent de synonymes pour l'étiquette de référence. 
	\item Les étiquettes cachées (\cd{skos:hiddenLabel}) qui servent à la récupération d'erreurs de frappes les plus courantes. 
\end{liste}
Chacune de ces propriétés est formalisée comme une instance de \cd{owl:Anno\-tationProperty}, ce qui permet de l'attacher dans les faits à tout type d'éléments ontologiques, et pas seulement à des concepts. 
Les valeurs lexicales portées par ces étiquettes sont formalisées comme des \cd{rdf:PlainLiteral}, ce qui permet de spécifier la langue et l'alphabet utilisés. 
Par exemple, la chaîne "higashi"@ja-Latn correspond à un mot japonais écrit avec l'alphabet latin.

\paragraph{Documentation}
Différentes notes de documentation existent afin de :
\begin{liste}
	\item Définir un concept (\cd{skos:definition}), expliciter son contexte d'usage (\cd{skos:scopeNote}) ou donner des exemples (\cd{skos:example}).
	\item Spécifier l'historique de sa signification (\cd{skos:historyNote}), les changements effectués (\cd{skos:changeNote}) ou à faire (\cd{skos:editorialNote}).
\end{liste}
L'ensemble de ces notes est défini comme une spécialisation de \cd{skos:note}, formalisé comme une \cd{owl:annotationProperty}. 
De cette manière, les notes peuvent servir à porter de la documentation écrite (comme les étiquettes), pointer vers des ressources RDF ou des documents identifiés par une URI. 
Cela permet ainsi de prévoir l'extension de ces notes à des besoins plus spécifiques.


\paragraph{Groupes et relations entre Concepts}
Les concepts peuvent être regroupés dans des schémas conceptuels (\cd{skos:\-ConceptScheme} et relation \cd{skos:inScheme}) et structurés par différentes relations:
\begin{liste}
	\item Des relations de structuration hiérarchiques (\cd{skos:broader}, \cd{skos:na\-rrower}) ou associatives (\cd{skos:related})
	\item Des relations de correspondances entre concepts de schémas différents, soit une relation d'équivalence exacte (\cd{skos:exactMatch}), une équivalence approximative (\cd{skos:closeMatch}), des relations hiérarchiques (\cd{skos:broadMatch}, \cd{skos:narrowMatch}) ou associative \cd{skos:rela\-ted\-Match}).
\end{liste}



\paragraph{Exemple de représentation} 
Pour illustrer l'utilisation de SKOS, nous reprendrons le scénario présenté dans notre cahier des charges fonctionnels (\ref{sec:cdcf}). 
Il s'agit de représenter deux termes de jargons correspondant au même concept de cadrage.
En effet, les deux organisations ont décidé de lier la définition de leur concept malgré leur usage d'étiquettes différent. 
Ceci se reflète par la mise en relation explicite de ces concepts (\cd{skos:exactMatch}) et leur incorporation dans des schèmes différents (\cd{skos:inScheme}).
Par ailleurs, la VRT utilise des étiquettes cachées pour gérer l'utilisation d'abréviations par les utilisateurs écrivant leurs requêtes. 
Afin de satisfaire aux besoins des amateurs, on rajoute également une illustration graphique ainsi qu'une définition :
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
//====== CONCEPTS ======//
<PlanAmericain> rdf:type skos:Concept ; 
  skos:prefLabel "Plan américain"@fr ;
  skos:prefLabel "American shot"@en
  skos:altLabel "Plan 3/4"@fr ;
  skos:altLabel "Medium-close shot"@en ;
  skos:inScheme   <RTBF-Scheme> ;
  skos:inScheme   <AV-Scheme> ;
  skos:example ex:PlanAmericain.png ;                               //Illustration//
  skos:definition "plan coupant les personnages à mi-cuisse"@fr ;   //Définition//
  skos:exactMatch <Plan34> .
   
<Plan34> rdf:type skos:Concept ;
  skos:prefLabel "3/4 shot"@en
  skos:prefLabel "Plan 3/4"@fr ;
  skos:altLabel "Medium-close shot"@en ;
  skos:hiddenLabel "mcs"@en ;                                       //Abréviations//
  skos:hiddenLabel "m.c.s."@en ;
  skos:example ex:PlanAmericain.png ;                               //Illustration//
  skos:definition "shows a character from head to the middle of the leg"@en ;
  skos:inScheme   <AV-Scheme> ;
  skos:inScheme   <VRT-Scheme> .
\end{Verbatim}



\paragraph{SKOS-XL}\label{sec:skos-xl}
SKOS-XL est une extension de SKOS développée courant 2008 pour proposer une modélisation alternative au vocabulaire de base et favoriser des extensions plus fines. 
Dans SKOS-XL les termes ne sont plus portés par les concepts mais deviennent des éléments à part entière (\cd{skosxl:Label}). 

Les relations d'attachement entre termes et concepts sont analogues aux attributs de SKOS mais les formalisent comme des instances de \cd{owl:objectProperty}. 
Le domaine de ces relations n'est pas défini ce qui permet de les associer à n'importe quelle ressource RDF, et donc en particulier aux concepts SKOS mais également à des ConceptScheme. 
Si cette dernière possibilité permet de créer des groupes de termes, elle introduit une confusion sur la sémantique des ConceptScheme.
Est-ce un groupe de concepts, de termes ou bien de triplets ? 
Les étiquettes portent une seule chaîne lexicale avec les mêmes possibilités que pour SKOS grâce à l'attribut \cd{skos:literalForm}. 
L'indépendance des étiquettes permet également de spécifier des relations entre eux comme la synonymie, la traduction, etc. \cite{Pastor2009a}. 
Cette possibilité est ouverte par la relation générique \cd{skosxl:labelRelation}. 


% REVOIR les termes par rapport à l'exemple de SKOS
\begin{Verbatim}[fontsize=\small,formatcom=\color{black!70}]
//====== CONCEPTS ======//
C-PlanAmericain rdf:type skos:Concept ; 
  skosxl:prefLabel <T-PlanAmericain> ;
  skosxl:prefLabel <T-AmericanShot> ;
  skosxl:altLabel <T-Plan34> ;
  skosxl:altLabel <T-MCShot> ;
  skos:example ex:PlanAmericain.png ;                               //Illustration//
  skos:definition "plan coupant les personnages à mi-cuisse"@fr ;   //Définition//
  skos:inScheme   <RTBF-Scheme> ;
  skos:inScheme   <AV-Scheme> ;
  skos:exactMatch <C-Plan34> .

C-Plan34 rdf:type skos:Concept ;
  skosxl:prefLabel <T-Plan34> ;
  skosxl:prefLabel <T-34Shot> ;
  skosxl:altLabel <T-MCShot> ;
  skosxl:hiddenLabel <T-MCS> ;                                      //Abréviations//
  skosxl:hiddenLabel <T-M-C-S> ;
  skos:example ex:PlanAmericain.png ;                               //Illustration//
  skos:definition "shows a character from head to the middle of the leg"@en ;
  skos:inScheme <AV-Scheme> ;
  skos:inScheme <VRT-Scheme> .

//====== TERMES ======//
T-PlanAmericain rdf:type skosxl:Label ;
  skosxl:literalForm "Plan américain"@fr .
T-AmericanShot rdf:type skosxl:Label ;
  skosxl:literalForm "American shot"@en .
T-MCShot rdf:type skosxl:Label ;
  skosxl:literalForm "Medium-close shot"@en .
T-Plan34 rdf:type skosxl:Label ;
  skosxl:literalForm "Plan 3/4"@fr .
T-34Shot rdf:type skosxl:Label ;
  skosxl:literalForm "3/4 shot"@en .
T-MCS  rdf:type skosxl:Label ;
  skosxl:literalForm "mcs"@en .
T-M-C-S  rdf:type skosxl:Label ;
  skosxl:literalForm "m.c.s."@en .
\end{Verbatim}


Dans SKOS, la gestion de plusieurs jargons métiers dans une même conceptualisation [\g{$\delta_1$ : multi-jargon}] est rendue difficile par la caractérisation simple des termes par la langue. 
Ainsi, même si on accroche plusieurs étiquettes au même concept, on ne sait pas les sélectionner pour les présenter à l'une ou l'autre communauté. 
Cela implique un dédoublement des concepts et donc des schémas conceptuels nécessaires (un par communauté). %, voir figure \ref{fig:skos}. 
%implique une représentation plus fine par rapport à SKOS ce qui 
Avec le découplage terme-concept de SKOS-XL, on peut gérer terme et concept de manière séparée sans pour autant avoir de primitives spécifiques pour regrouper les termes par jargon ou code d'écriture. %, voir figure \ref{fig:skosxl}. 
Une solution consisterait à regrouper les termes dans des ConceptScheme (SKOS-XL l'autorise).
Les ConceptScheme serviraient alors à la fois à regrouper les concepts (AV-Scheme) et les termes spécifiques aux organisations (RTBF-Scheme, VRT-Scheme). 
Cependant, si cette modélisation permet de gérer vocabulaire métier et conceptualisation de manière séparée c'est au prix d'un flottement sur la sémantique de ConceptScheme. 
Le support d'un nouveau jargon peut donc se faire sans toucher à la conceptualisation [\g{$\delta_3$: gestion, évolution}] grâce à la permissivité de l'extension SKOS-XL. 
L'extension ou la mise en correspondance de la conceptualisation est facilitée par les relations sémantiques entre concepts.


\subsubsection{ISO 25964-1}
% \addcontentsline{toc}{subsubsection}{ISO 25964-1}
Cette norme propose une modélisation terme-concept similaire à SKOS-XL mais se concentre sur la représentation des thésaurus. 
Elle se fonde sur des modèles pré-existants, le méta-modèle de \cite{Vandenbussche2009} ainsi que la norme BS 8723. 
L'originalité par rapport à SKOS est de considérer la composition de termes ou de concepts et d'enrichir la description des éléments du modèle par des attributs Dublin Core.

Les termes se distinguent entre termes préférés simples ou composés et termes non préférés simples. 
La caractérisation des termes porte également sur l'appartenance à une langue à laquelle s'ajoutent des attributs de date, une définition ainsi que des notes d'historique et de révision. 
Des relations sémantiques entre termes sont également considérées en particulier l'équivalence composée, la synonymie, l'abréviation, l'acronyme, etc. 
Le thésaurus est considéré comme l'élément central décrit par l'ensemble des quinze attributs originaux du Dublin Core ainsi que des notes d'historique pour la maintenance. 
Sur les questions de documentation et de groupement de concepts, il existe une similarité importante avec les primitives de SKOS (note, groupe de concepts, etc.).\\

%\textbf{Discussion}\\
Les apports de la norme ISO 25964 par rapport à SKOS concernent davantage les pratiques de création et de maintenance de thésaurus que la gestion des jargons métiers [\g{$\delta_1$ : multi-jargon}] et l'illustration de concepts par des ressources média [\g{$\delta_2$ : documentation}]. 
Ainsi, les manques par rapport à nos besoins sont similaires. L'attention portée sur les détails de description de chaque élément du modèle est tout à fait convaincante. 
L'écart avec l'aspect épuré et synthétique de SKOS s'explique certainement par l'écart entre leurs objectifs. 
Alors que SKOS vise la publication de tout type de SOC, l'ISO 25946 se concentre sur la construction et l'évolution des seuls thésaurus. 
La norme ne s'est pas encore attelée aux questions d'interopérabilité et de correspondance avec d'autres vocabulaires. Ce travail est en cours et sera dévoilé dans la seconde partie de la norme (ISO 25946-2). 
De notre point de vue, il manque toujours un moyen de regrouper des termes indépendamment des concepts pour ajouter des jargons à une conceptualisation existante [\g{$\delta_3$: gestion, évolution}].


% \subsection*{Bilan}



\subsection*{Discussion}
\addcontentsline{toc}{subsection}{Discussion}
% Partie sur les LN de représentations

L'étude des standards et normes de références précédentes ne semble pas apporter de solution complètement satisfaisante pour l'ensemble de nos besoins. 
En effet, les approches restent centrées sur le concept et sa structuration auquel on intègre (SKOS) ou rattache (SKOS-XL, ISO 25946-1) ensuite les termes. 
Ces derniers sont représentés de manière plus ou moins fine (gestion des compositions dans ISO 25946 absente de SKOS). 
Dans tous les cas, la préférence d'un terme s'établit uniquement sur l'appartenance à une langue et non par rapport à une communauté de jargon. % mais sont caractérisés de manière identique dans les deux modèles (appartenance à une langue). 
De ce fait, ces modèles se limitent à représenter un seul jargon de référence par thésaurus et suppose ainsi l'existence d'une communauté homogène dans sa compréhension dont on cherche à normaliser l'usage linguistique. %
Dans notre cas, la collaboration entre communautés hétérogènes dans leur compréhension des concepts et leur utilisation de la langue exige de pouvoir gérer plusieurs jargons. 
% C'est pourquoi nous proposons dans la suite un modèle Multi-Jargon afin d'associer plusieurs jargons métiers et des explications à une conceptualisation commune. %basé sur des concepts originaux 